%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This script uses the nomenclature, formulations and solutions from:
%   M. Avillez and D. Arnas, "Osculating and Mean Asynchronous Relative Motion Approximations 
%   Under J2 and Atmospheric Drag", TODO
%
% Summary:
%   Computes the derivative of the state with respect to the argument of latitude.
%
% Inputs:
%   tt: argument of latitude
%   state: absolute state of the spacecraft: [bb; x; y; p; oo; t]
%   mu: gravitational parameter
%   R: Radius of the central planet
%   j2: J2 coefficient of the gravity model
%   accFunction(tt, state): function handle to compute the RTN acceleration
%
% Outputs:
%   stateDerivative: derivative of the state with respect to the argument of latitude
%
%
% Authors: Miguel Avillez and David Arnas
% Modified: August 2025
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function stateDerivative = stateArgLatDerivative(tt, state, mu, R, j2, accFunction)

  % Extract state elements
  bb = state(1);
  x = state(2);
  y = state(3);
  p = state(4);

  % Compute RTN acceleration
  acc = accFunction(tt, state);
  % Extract acceleration components
  ar = acc(1);
  af = acc(2);
  ah = acc(3);

  % Compute state derivatives
  dbbDtt = af.*bb.^(-3).*mu.^(-1).*R.^2.*(1+(-1).*j2.^2.*x.^2+(-1).*j2.^2.* ...
    y.^2).^(-1).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-2).*(1+(-1).* ...
    ah.*bb.^(-3).*mu.^(-1).*p.*(1+(-1).*bb.^2.*p.^2).^(-1/2).*R.^2.* ...
    sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-3)).^(-1).*((-1)+ ...
    j2.*x.*cos(tt)+j2.*y.*sin(tt)+((-1).*j2.*y.*cos(tt)+j2.*x.*sin(tt) ...
    ).^2.*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-1));
  dxDtt = bb.^(-4).*j2.^(-1).*mu.^(-1).*R.^2.*(1+j2.*x.*cos(tt)+j2.*y.*sin( ...
    tt)).^(-2).*(1+(-1).*ah.*bb.^(-3).*mu.^(-1).*p.*(1+(-1).*bb.^2.* ...
    p.^2).^(-1/2).*R.^2.*sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^( ...
    -3)).^(-1).*(ar.*sin(tt)+ah.*bb.*j2.*p.*(1+(-1).*bb.^2.*p.^2).^( ...
    -1/2).*y.*sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-1)+af.*( ...
    2.*cos(tt)+sin(tt).*((-1).*j2.*y.*cos(tt)+j2.*x.*sin(tt)).*(1+j2.* ...
    x.*cos(tt)+j2.*y.*sin(tt)).^(-1)));
  dyDtt = bb.^(-4).*j2.^(-1).*mu.^(-1).*R.^2.*(1+j2.*x.*cos(tt)+j2.*y.*sin( ...
    tt)).^(-2).*(1+(-1).*ah.*bb.^(-3).*mu.^(-1).*p.*(1+(-1).*bb.^2.* ...
    p.^2).^(-1/2).*R.^2.*sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^( ...
    -3)).^(-1).*((-1).*ar.*cos(tt)+(-1).*ah.*bb.*j2.*p.*(1+(-1).* ...
    bb.^2.*p.^2).^(-1/2).*x.*sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt) ...
    ).^(-1)+af.*(2.*sin(tt)+(-1).*cos(tt).*((-1).*j2.*y.*cos(tt)+j2.* ...
    x.*sin(tt)).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-1)));
  dpDtt = bb.^(-5).*mu.^(-1/2).*R.^(3/2).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)) ...
    .^(-2).*(1+(-1).*ah.*bb.^(-3).*mu.^(-1).*p.*(1+(-1).*bb.^2.*p.^2) ...
    .^(-1/2).*R.^2.*sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-3)) ...
    .^(-1).*((-1).*ah.*mu.^(-1/2).*(1+(-1).*bb.^2.*p.^2).^(1/2).*R.^( ...
    1/2).*cos(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-1)+(-1).*af.* ...
    bb.*mu.^(-1/2).*p.*R.^(1/2).*(1+(-1).*j2.^2.*x.^2+(-1).*j2.^2.* ...
    y.^2).^(-1).*((-1)+j2.*x.*cos(tt)+j2.*y.*sin(tt)+((-1).*j2.*y.* ...
    cos(tt)+j2.*x.*sin(tt)).^2.*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^( ...
    -1)));
  dooDtt = ah.*bb.^(-4).*mu.^(-1).*(1+(-1).*bb.^2.*p.^2).^(-1/2).*R.^2.*sin( ...
    tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-3).*(1+(-1).*ah.*bb.^( ...
    -3).*mu.^(-1).*p.*(1+(-1).*bb.^2.*p.^2).^(-1/2).*R.^2.*sin(tt).*( ...
    1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-3)).^(-1);
  dtDtt = bb.^(-3).*mu.^(-1/2).*R.^(3/2).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)) ...
    .^(-2).*(1+(-1).*ah.*bb.^(-3).*mu.^(-1).*p.*(1+(-1).*bb.^2.*p.^2) ...
    .^(-1/2).*R.^2.*sin(tt).*(1+j2.*x.*cos(tt)+j2.*y.*sin(tt)).^(-3)) ...
    .^(-1);

  % Concatenate state derivatives
  stateDerivative = [dbbDtt; dxDtt; dyDtt; dpDtt; dooDtt; dtDtt];

end